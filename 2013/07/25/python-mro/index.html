<!doctype html><html lang=en-us><head><title>Python的方法解析顺序(MRO) - Stone Horse</title><meta http-equiv=x-ua-compatible content="ie=edge"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel=stylesheet href=https://hanjianwei.com/style.css></head><body><div class=container><header><nav><ul><li><a href=/>Home</a></li><li><a href=/posts>Archives</a></li><li><a href=/tags>Tags</a></li></ul></nav></header><main><div class=post><article><h1>Python的方法解析顺序(MRO)</h1><time>Jul 25, 2013</time><p><p>对于支持继承的编程语言来说，其方法（属性）可能定义在当前类，也可能来自于基类，所以在方法调用时就需要对当前类和基类进行搜索以确定方法所在的位置。而搜索的顺序就是所谓的「方法解析顺序」（Method Resolution Order，或MRO）。对于只支持单继承的语言来说，MRO 一般比较简单；而对于 Python 这种支持多继承的语言来说，MRO 就复杂很多。</p><p>先看一个「菱形继承」的例子：</p><p><img src=class_diamond.svg alt=菱形继承></p><p>如果 <code>x</code> 是 <code>D</code> 的一个实例，那么 <code>x.show()</code> 到底会调用哪个 <code>show</code> 方法呢？如果按照 <code>[D, B, A, C]</code> 的搜索顺序，那么 <code>x.show()</code> 会调用 <code>A.show()</code>；如果按照 <code>[D, B, C, A]</code> 的搜索顺序，那么 <code>x.show()</code> 会调用 <code>C.show()</code>。由此可见，MRO 是把类的继承关系线性化的一个过程，而线性化方式决定了程序运行过程中具体会调用哪个方法。既然如此，那什么样的 MRO 才是最合理的？Python 中又是如何实现的呢？</p><p>Python 至少有<a href=http://python-history.blogspot.com/2010/06/method-resolution-order.html>三种不同的 MRO</a>：</p><ol><li>经典类（classic class）的深度遍历。</li><li>Python 2.2 的新式类（new-style class）预计算。</li><li>Python 2.3 的新式类的<a href=http://en.wikipedia.org/wiki/C3_linearization> C3 算法</a>。它也是 Python 3 唯一支持的方式。</li></ol><h3 id=经典类的-mro>经典类的 MRO</h3><p>Python 有<a href=http://wiki.python.org/moin/NewClassVsClassicClass>两种类</a>：经典类（classic class）和新式类（new-style class）。两者的不同之处在于新式类继承自 <code>object</code>。在 Python 2.1 以前，经典类是唯一可用的形式；Python 2.2 引入了新式类，使得类和内置类型更加统一；在 Python 3 中，新式类是唯一支持的类。</p><p>经典类采用了一种很简单的 MRO 方法：从左至右的<a href=http://en.wikipedia.org/wiki/Depth-first_search>深度优先遍历</a>。以上述「菱形继承」为例，其查找顺序为 <code>[D, B, A, C, A]</code>，如果只保留重复类的第一个则结果为 <code>[D, B, A, C]</code>。我们可以用 <code>inspect.getmro</code> 来获取类的 MRO：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=o>&gt;&gt;&gt;</span> <span class=kn>import</span> <span class=nn>inspect</span>
<span class=o>&gt;&gt;&gt;</span> <span class=k>class</span> <span class=nc>A</span><span class=p>:</span>
<span class=o>...</span>     <span class=k>def</span> <span class=nf>show</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=o>...</span>         <span class=k>print</span> <span class=s2>&#34;A.show()&#34;</span>
<span class=o>...</span>
<span class=o>&gt;&gt;&gt;</span> <span class=k>class</span> <span class=nc>B</span><span class=p>(</span><span class=n>A</span><span class=p>):</span> <span class=k>pass</span>
<span class=o>&gt;&gt;&gt;</span> <span class=k>class</span> <span class=nc>C</span><span class=p>(</span><span class=n>A</span><span class=p>):</span>
<span class=o>...</span>     <span class=k>def</span> <span class=nf>show</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=o>...</span>         <span class=k>print</span> <span class=s2>&#34;C.show()&#34;</span>
<span class=o>...</span>
<span class=o>&gt;&gt;&gt;</span> <span class=k>class</span> <span class=nc>D</span><span class=p>(</span><span class=n>B</span><span class=p>,</span> <span class=n>C</span><span class=p>):</span> <span class=k>pass</span>
<span class=o>&gt;&gt;&gt;</span> <span class=n>inspect</span><span class=o>.</span><span class=n>getmro</span><span class=p>(</span><span class=n>D</span><span class=p>)</span>
<span class=p>(</span><span class=o>&lt;</span><span class=k>class</span> <span class=nc>__main__</span><span class=o>.</span><span class=n>D</span> <span class=n>at</span> <span class=mh>0x105f0a6d0</span><span class=o>&gt;</span><span class=p>,</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>__main__</span><span class=o>.</span><span class=n>B</span> <span class=n>at</span> <span class=mh>0x105f0a600</span><span class=o>&gt;</span><span class=p>,</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>__main__</span><span class=o>.</span><span class=n>A</span> <span class=n>at</span> <span class=mh>0x105f0a668</span><span class=o>&gt;</span><span class=p>,</span> <span class=o>&lt;</span><span class=k>class</span> <span class=nc>__main__</span><span class=o>.</span><span class=n>C</span> <span class=n>at</span> <span class=mh>0x105f0a738</span><span class=o>&gt;</span><span class=p>)</span>
<span class=o>&gt;&gt;&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>D</span><span class=p>()</span>
<span class=o>&gt;&gt;&gt;</span> <span class=n>x</span><span class=o>.</span><span class=n>show</span><span class=p>()</span>
<span class=n>A</span><span class=o>.</span><span class=n>show</span><span class=p>()</span>
</code></pre></div><p>这种深度优先遍历对于简单的情况还能处理的不错，但是对于上述「菱形继承」其结果却不尽如人意：虽然 <code>C.show()</code> 是 <code>A.show()</code> 的更具体化版本（显示了更多的信息），但我们的 <code>x.show()</code> 没有调用它，而是调用了 <code>A.show()</code>。这显然不是我们希望的结果。</p><p>对于新式类而言，所有的类都继承自 <code>object</code>，所以「菱形继承」是非常普遍的现象，因此不可能采用这种 MRO 方式。</p><h3 id=python-22-的新式类-mro>Python 2.2 的新式类 MRO</h3><p>为解决经典类 MRO 所存在的问题，Python 2.2 针对新式类提出了一种新的 MRO 计算方式：在定义类时就计算出该类的 MRO 并将其作为类的属性。因此新式类可以直接通过 <code>__mro__</code> 属性获取类的 MRO。</p><p>Python 2.2 的新式类 MRO 计算方式和经典类 MRO 的计算方式非常相似：它仍然采用从左至右的深度优先遍历，但是如果遍历中出现重复的类，只保留最后一个。重新考虑上面「菱形继承」的例子，由于新式类继承自 <code>object</code> 因此类图稍有改变：</p><p><img src=newclass_diamond.svg alt=新式类菱形继承></p><p>按照深度遍历，其顺序为 <code>[D, B, A, object, C, A, object]</code>，重复类只保留最后一个，因此变为 <code>[D, B, C, A, object]</code>。代码为：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=o>&gt;&gt;&gt;</span> <span class=k>class</span> <span class=nc>A</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span>
<span class=o>...</span>     <span class=k>def</span> <span class=nf>show</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=o>...</span>         <span class=k>print</span> <span class=s2>&#34;A.show()&#34;</span>
<span class=o>...</span>
<span class=o>&gt;&gt;&gt;</span> <span class=k>class</span> <span class=nc>B</span><span class=p>(</span><span class=n>A</span><span class=p>):</span> <span class=k>pass</span>
<span class=o>&gt;&gt;&gt;</span> <span class=k>class</span> <span class=nc>C</span><span class=p>(</span><span class=n>A</span><span class=p>):</span>
<span class=o>...</span>     <span class=k>def</span> <span class=nf>show</span><span class=p>(</span><span class=bp>self</span><span class=p>):</span>
<span class=o>...</span>         <span class=k>print</span> <span class=s2>&#34;C.show()&#34;</span>
<span class=o>...</span>
<span class=o>&gt;&gt;&gt;</span> <span class=k>class</span> <span class=nc>D</span><span class=p>(</span><span class=n>B</span><span class=p>,</span> <span class=n>C</span><span class=p>):</span> <span class=k>pass</span>
<span class=o>&gt;&gt;&gt;</span> <span class=n>D</span><span class=o>.</span><span class=vm>__mro__</span>
<span class=p>(</span><span class=o>&lt;</span><span class=k>class</span> <span class=err>&#39;</span><span class=nc>__main__</span><span class=o>.</span><span class=n>D</span><span class=s1>&#39;&gt;, &lt;class &#39;</span><span class=n>__main__</span><span class=o>.</span><span class=sa>B</span><span class=s1>&#39;&gt;, &lt;class &#39;</span><span class=n>__main__</span><span class=o>.</span><span class=n>C</span><span class=s1>&#39;&gt;, &lt;class &#39;</span><span class=n>__main__</span><span class=o>.</span><span class=n>A</span><span class=s1>&#39;&gt;, &lt;type &#39;</span><span class=nb>object</span><span class=s1>&#39;&gt;)</span>
<span class=o>&gt;&gt;&gt;</span> <span class=n>x</span> <span class=o>=</span> <span class=n>D</span><span class=p>()</span>
<span class=o>&gt;&gt;&gt;</span> <span class=n>x</span><span class=o>.</span><span class=n>show</span><span class=p>()</span>
<span class=n>C</span><span class=o>.</span><span class=n>show</span><span class=p>()</span>
</code></pre></div><p>这种 MRO 方式已经能够解决「菱形继承」问题，再让我们看个稍微复杂点的例子：</p><p><img src=class_conflict.svg alt=类型冲突></p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=o>&gt;&gt;&gt;</span> <span class=k>class</span> <span class=nc>X</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span> <span class=k>pass</span>
<span class=o>&gt;&gt;&gt;</span> <span class=k>class</span> <span class=nc>Y</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span> <span class=k>pass</span>
<span class=o>&gt;&gt;&gt;</span> <span class=k>class</span> <span class=nc>A</span><span class=p>(</span><span class=n>X</span><span class=p>,</span> <span class=n>Y</span><span class=p>):</span> <span class=k>pass</span>
<span class=o>&gt;&gt;&gt;</span> <span class=k>class</span> <span class=nc>B</span><span class=p>(</span><span class=n>Y</span><span class=p>,</span> <span class=n>X</span><span class=p>):</span> <span class=k>pass</span>
<span class=o>&gt;&gt;&gt;</span> <span class=k>class</span> <span class=nc>C</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>B</span><span class=p>):</span> <span class=k>pass</span>
</code></pre></div><p>首先进行深度遍历，结果为 <code>[C, A, X, object, Y, object, B, Y, object, X, object]</code>；然后，只保留重复元素的最后一个，结果为 <code>[C, A, B, Y, X, object]</code>。Python 2.2 在实现该方法的时候进行了调整，使其更尊重基类中类出现的顺序，其实际结果为 <code>[C, A, B, X, Y, object]</code>。</p><p>这样的结果是否合理呢？首先我们看下各个类中的方法解析顺序：对于 <code>A</code> 来说，其搜索顺序为 <code>[A, X, Y, object]</code>；对于 <code>B</code>，其搜索顺序为 <code>[B, Y, X, object]</code>；对于 <code>C</code>，其搜索顺序为 <code>[C, A, B, X, Y, object]</code>。我们会发现，<code>B</code> 和 <code>C</code> 中 <code>X</code>、<code>Y</code> 的搜索顺序是相反的！也就是说，当 <code>B</code> 被继承时，它本身的行为竟然也发生了改变，这很容易导致不易察觉的错误。此外，即使把 <code>C</code> 搜索顺序中 <code>X</code> 和 <code>Y</code> 互换仍然不能解决问题，这时候它又会和 <code>A</code> 中的搜索顺序相矛盾。</p><p>事实上，不但上述特殊情况会出现问题，在<a href=http://mail.python.org/pipermail/python-dev/2002-October/029035.html>其它情况</a>下也可能出问题。其原因在于，上述继承关系违反了线性化的「 <strong>单调性原则</strong> 」。<a href=http://www.python.org/download/releases/2.3/mro/>Michele Simionato</a>对单调性的定义为：</p><blockquote><p>A MRO is monotonic when the following is true: if C1 precedes C2 in the linearization of C, then C1 precedes C2 in the linearization of any subclass of C. Otherwise, the innocuous operation of deriving a new class could change the resolution order of methods, potentially introducing very subtle bugs.</p></blockquote><p>也就是说，子类不能改变基类的方法搜索顺序。在 Python 2.2 的 MRO 算法中并不能保证这种单调性，它不会阻止程序员写出上述具有二义性的继承关系，因此很可能成为错误的根源。</p><p>除了单调性之外，Python 2.2 及 经典类的 MRO 也可能违反继承的「 <strong>局部优先级</strong> 」，具体例子可以参见<a href=http://www.python.org/download/releases/2.3/mro/#bad-method-resolution-orders>官方文档</a>。采用一种更好的 MRO 方式势在必行。</p><h3 id=c3-mro>C3 MRO</h3><p>为解决 Python 2.2 中 MRO 所存在的问题，Python 2.3以后采用了<a href=http://en.wikipedia.org/wiki/C3_linearization> C3 方法</a>来确定方法解析顺序。你如果在 Python 2.3 以后版本里输入上述代码，就会产生一个异常，禁止创建具有二义性的继承关系：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=o>&gt;&gt;&gt;</span> <span class=k>class</span> <span class=nc>C</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>B</span><span class=p>):</span> <span class=k>pass</span>
<span class=n>Traceback</span> <span class=p>(</span><span class=n>most</span> <span class=n>recent</span> <span class=n>call</span> <span class=n>last</span><span class=p>):</span>
  <span class=n>File</span> <span class=s2>&#34;&lt;ipython-input-8-01bae83dc806&gt;&#34;</span><span class=p>,</span> <span class=n>line</span> <span class=mi>1</span><span class=p>,</span> <span class=ow>in</span> <span class=o>&lt;</span><span class=n>module</span><span class=o>&gt;</span>
    <span class=k>class</span> <span class=nc>C</span><span class=p>(</span><span class=n>A</span><span class=p>,</span> <span class=n>B</span><span class=p>):</span> <span class=k>pass</span>
<span class=ne>TypeError</span><span class=p>:</span> <span class=n>Error</span> <span class=n>when</span> <span class=n>calling</span> <span class=n>the</span> <span class=n>metaclass</span> <span class=n>bases</span>
    <span class=n>Cannot</span> <span class=n>create</span> <span class=n>a</span> <span class=n>consistent</span> <span class=n>method</span> <span class=n>resolution</span>
<span class=n>order</span> <span class=p>(</span><span class=n>MRO</span><span class=p>)</span> <span class=k>for</span> <span class=n>bases</span> <span class=n>X</span><span class=p>,</span> <span class=n>Y</span>
</code></pre></div><p>我们把类 <code>C</code> 的线性化（MRO）记为 <code>L[C] = [C1, C2,…,CN]</code>。其中 <code>C1</code> 称为 <code>L[C]</code> 的头，其余元素 <code>[C2,…,CN]</code> 称为尾。如果一个类 <code>C</code> 继承自基类 <code>B1</code>、<code>B2</code>、……、<code>BN</code>，那么我们可以根据以下两步计算出 <code>L[C]</code>：</p><ol><li><code>L[object] = [object]</code></li><li><code>L[C(B1…BN)] = [C] + merge(L[B1]…L[BN], [B1]…[BN])</code></li></ol><p>这里的关键在于 <code>merge</code>，其输入是一组列表，按照如下方式输出一个列表：</p><ol><li>检查第一个列表的头元素（如 <code>L[B1]</code> 的头），记作 <code>H</code>。</li><li>若 <code>H</code> 未出现在其它列表的尾部，则将其输出，并将其从所有列表中删除，然后回到步骤1；否则，取出下一个列表的头部记作 <code>H</code>，继续该步骤。</li><li>重复上述步骤，直至列表为空或者不能再找出可以输出的元素。如果是前一种情况，则算法结束；如果是后一种情况，说明无法构建继承关系，Python 会抛出异常。</li></ol><p>该方法有点类似于图的<a href=http://en.wikipedia.org/wiki/Topological_sorting>拓扑排序</a>，但它同时还考虑了基类的出现顺序。我们用 C3 分析一下刚才的例子。</p><p><code>object</code>，<code>X</code>，<code>Y</code> 的线性化结果比较简单：</p><div class=highlight><pre class=chroma><code class=language-plaintext data-lang=plaintext>L[object] = [object]
L[X] = [X, object]
L[Y] = [Y, object]
</code></pre></div><p><code>A</code> 的线性化计算如下：</p><div class=highlight><pre class=chroma><code class=language-plaintext data-lang=plaintext>L[A] = [A] + merge(L[X], L[Y], [X], [Y])
     = [A] + merge([X, object], [Y, object], [X], [Y])
     = [A, X] + merge([object], [Y, object], [Y])
     = [A, X, Y] + merge([object], [object])
     = [A, X, Y, object]
</code></pre></div><p>注意第3步，<code>merge([object], [Y, object], [Y])</code> 中首先输出的是 <code>Y</code> 而不是 <code>object</code>。这是因为 <code>object</code> 虽然是第一个列表的头，但是它出现在了第二个列表的尾部。所以我们会跳过第一个列表，去检查第二个列表的头部，也就是 <code>Y</code>。<code>Y</code> 没有出现在其它列表的尾部，所以将其输出。</p><p>同理，<code>B</code> 的线性化结果为：</p><div class=highlight><pre class=chroma><code class=language-plaintext data-lang=plaintext>L[B] = [B, Y, X, object]
</code></pre></div><p>最后，我们看看 <code>C</code> 的线性化结果：</p><div class=highlight><pre class=chroma><code class=language-plaintext data-lang=plaintext>L[C] = [C] + merge(L[A], L[B], [A], [B])
     = [C] + merge([A, X, Y, object], [B, Y, X, object], [A], [B])
     = [C, A] + merge([X, Y, object], [B, Y, X, object], [B])
     = [C, A, B] + merge([X, Y, object], [Y, X, object])
</code></pre></div><p>到了最后一步我们没有办法继续计算下去 了：<code>X</code> 虽然是第一个列表的头，但是它出现在了第二个列表的尾部；<code>Y</code> 虽然是第二个列表的头，但是它出现在了第一个列表的尾部。因此，我们无法构建一个没有二义性的继承关系，只能手工去解决（比如改变 <code>B</code> 基类中 <code>X</code>、<code>Y</code> 的顺序）。</p><p>我们再看一个没有冲突的例子：</p><p><img src=c3_example.svg alt=C3例子></p><p>计算过程如下：</p><div class=highlight><pre class=chroma><code class=language-plaintext data-lang=plaintext>L[object] = [object]
L[D] = [D, object]
L[E] = [E, object]
L[F] = [F, object]
L[B] = [B, D, E, object]
L[C] = [C, D, F, object]
L[A] = [A] + merge(L[B], L[C], [B], [C])
     = [A] + merge([B, D, E, object], [C, D, F, object], [B], [C])
     = [A, B] + merge([D, E, object], [C, D, F, object], [C])
     = [A, B, C] + merge([D, E, object], [D, F, object])
     = [A, B, C, D] + merge([E, object], [F, object])
     = [A, B, C, D, E] + merge([object], [F, object])
     = [A, B, C, D, E, F] + merge([object], [object])
     = [A, B, C, D, E, F, object]
</code></pre></div><p>当然，可以用代码验证类的 MRO，上面的例子可以写作：</p><div class=highlight><pre class=chroma><code class=language-python data-lang=python><span class=o>&gt;&gt;&gt;</span> <span class=k>class</span> <span class=nc>D</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span> <span class=k>pass</span>
<span class=o>&gt;&gt;&gt;</span> <span class=k>class</span> <span class=nc>E</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span> <span class=k>pass</span>
<span class=o>&gt;&gt;&gt;</span> <span class=k>class</span> <span class=nc>F</span><span class=p>(</span><span class=nb>object</span><span class=p>):</span> <span class=k>pass</span>
<span class=o>&gt;&gt;&gt;</span> <span class=k>class</span> <span class=nc>B</span><span class=p>(</span><span class=n>D</span><span class=p>,</span> <span class=n>E</span><span class=p>):</span> <span class=k>pass</span>
<span class=o>&gt;&gt;&gt;</span> <span class=k>class</span> <span class=nc>C</span><span class=p>(</span><span class=n>D</span><span class=p>,</span> <span class=n>F</span><span class=p>):</span> <span class=k>pass</span>
<span class=o>&gt;&gt;&gt;</span> <span class=k>class</span> <span class=nc>A</span><span class=p>(</span><span class=n>B</span><span class=p>,</span> <span class=n>C</span><span class=p>):</span> <span class=k>pass</span>
<span class=o>&gt;&gt;&gt;</span> <span class=n>A</span><span class=o>.</span><span class=vm>__mro__</span>
<span class=p>(</span><span class=o>&lt;</span><span class=k>class</span> <span class=err>&#39;</span><span class=nc>__main__</span><span class=o>.</span><span class=n>A</span><span class=s1>&#39;&gt;, &lt;class &#39;</span><span class=n>__main__</span><span class=o>.</span><span class=sa>B</span><span class=s1>&#39;&gt;, &lt;class &#39;</span><span class=n>__main__</span><span class=o>.</span><span class=n>C</span><span class=s1>&#39;&gt;, &lt;class &#39;</span><span class=n>__main__</span><span class=o>.</span><span class=n>D</span><span class=s1>&#39;&gt;, &lt;class &#39;</span><span class=n>__main__</span><span class=o>.</span><span class=n>E</span><span class=s1>&#39;&gt;, &lt;class &#39;</span><span class=n>__main__</span><span class=o>.</span><span class=n>F</span><span class=s1>&#39;&gt;, &lt;type &#39;</span><span class=nb>object</span><span class=s1>&#39;&gt;)</span>
</code></pre></div></p></article><aside class=comments><div id=disqus_thread></div></aside><script>var disqus_shortname='hjwblog';var disqus_identifier='\/2013\/07\/25\/python-mro\/';(function(){var dsq=document.createElement('script');dsq.type='text/javascript';dsq.async=true;dsq.src='//'+disqus_shortname+'.disqus.com/embed.js';(document.getElementsByTagName('head')[0]||document.getElementsByTagName('body')[0]).appendChild(dsq);})();</script></div></main><footer>&copy; 2013 - 2020 Jianwei Han.
<a href=https://www.github.com/hanjianwei/hanjianwei.github.io/tree/hugo><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 640 512"><path d="M278.9 511.5l-61-17.7c-6.4-1.8-10-8.5-8.2-14.9L346.2 8.7c1.8-6.4 8.5-10 14.9-8.2l61 17.7c6.4 1.8 10 8.5 8.2 14.9L293.8 503.3c-1.9 6.4-8.5 10.1-14.9 8.2zm-114-112.2 43.5-46.4c4.6-4.9 4.3-12.7-.8-17.2L117 256l90.6-79.7c5.1-4.5 5.5-12.3.8-17.2l-43.5-46.4c-4.5-4.8-12.1-5.1-17-.5L3.8 247.2c-5.1 4.7-5.1 12.8.0 17.5l144.1 135.1c4.9 4.6 12.5 4.4 17-.5zm327.2.6 144.1-135.1c5.1-4.7 5.1-12.8.0-17.5L492.1 112.1c-4.8-4.5-12.4-4.3-17 .5L431.6 159c-4.6 4.9-4.3 12.7.8 17.2L523 256l-90.6 79.7c-5.1 4.5-5.5 12.3-.8 17.2l43.5 46.4c4.5 4.9 12.1 5.1 17 .6z"/></svg></a><a href=https://www.github.com/hanjianwei><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 480 512"><path d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8.0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8.0-21.5 4.9-32.3 14.6-51.8 45.3.0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8.0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9.0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2.0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8.0-73.5 38.7-73.5 82.6.0 87.8 80.4 101.3 150.4 101.3h48.2c70.3.0 150.6-13.4 150.6-101.3zm-82.6-55.1c-25.8.0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z"/></svg></a><a href=https://twitter.com/hanjianwei><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M459.37 151.716c.325 4.548.325 9.097.325 13.645.0 138.72-105.583 298.558-298.558 298.558-59.452.0-114.68-17.219-161.137-47.106 8.447.974 16.568 1.299 25.34 1.299 49.055.0 94.213-16.568 130.274-44.832-46.132-.975-84.792-31.188-98.112-72.772 6.498.974 12.995 1.624 19.818 1.624 9.421.0 18.843-1.3 27.614-3.573-48.081-9.747-84.143-51.98-84.143-102.985v-1.299c13.969 7.797 30.214 12.67 47.431 13.319-28.264-18.843-46.781-51.005-46.781-87.391.0-19.492 5.197-37.36 14.294-52.954 51.655 63.675 129.3 105.258 216.365 109.807-1.624-7.797-2.599-15.918-2.599-24.04.0-57.828 46.782-104.934 104.934-104.934 30.213.0 57.502 12.67 76.67 33.137 23.715-4.548 46.456-13.32 66.599-25.34-7.798 24.366-24.366 44.833-46.132 57.827 21.117-2.273 41.584-8.122 60.426-16.243-14.292 20.791-32.161 39.308-52.628 54.253z"/></svg></a><a href=mailto:blog@hanjianwei.com><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M502.3 190.8c3.9-3.1 9.7-.2 9.7 4.7V4e2c0 26.5-21.5 48-48 48H48c-26.5.0-48-21.5-48-48V195.6c0-5 5.7-7.8 9.7-4.7 22.4 17.4 52.1 39.5 154.1 113.6 21.1 15.4 56.7 47.8 92.2 47.6 35.7.3 72-32.8 92.3-47.6 102-74.1 131.6-96.3 154-113.7zM256 320c23.2.4 56.6-29.2 73.4-41.4 132.7-96.3 142.8-104.7 173.4-128.7 5.8-4.5 9.2-11.5 9.2-18.9v-19c0-26.5-21.5-48-48-48H48C21.5 64 0 85.5.0 112v19c0 7.4 3.4 14.3 9.2 18.9 30.6 23.9 40.7 32.4 173.4 128.7 16.8 12.2 50.2 41.8 73.4 41.4z"/></svg></a><a title="PGP Key" href="https://pgp.mit.edu/pks/lookup?op=get&search=0x309B79EC85BB7488"><svg aria-hidden="true" focusable="false" data-prefix="fas" data-icon="key" class="svg-inline--fa fa-key fa-w-16" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path fill="currentcolor" d="M512 176.001C512 273.203 433.202 352 336 352c-11.22.0-22.19-1.062-32.827-3.069l-24.012 27.014A23.999 23.999.0 01261.223 384H224v40c0 13.255-10.745 24-24 24h-40v40c0 13.255-10.745 24-24 24H24c-13.255.0-24-10.745-24-24v-78.059c0-6.365 2.529-12.47 7.029-16.971l161.802-161.802C163.108 213.814 160 195.271 160 176 160 78.798 238.797.001 335.999.0 433.488-.001 512 78.511 512 176.001zM336 128c0 26.51 21.49 48 48 48s48-21.49 48-48-21.49-48-48-48-48 21.49-48 48z"/></svg></a><a href=/index.xml><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><path d="M128.081 415.959c0 35.369-28.672 64.041-64.041 64.041S0 451.328.0 415.959s28.672-64.041 64.041-64.041 64.04 28.673 64.04 64.041zm175.66 47.25c-8.354-154.6-132.185-278.587-286.95-286.95C7.656 175.765.0 183.105.0 192.253v48.069c0 8.415 6.49 15.472 14.887 16.018 111.832 7.284 201.473 96.702 208.772 208.772.547 8.397 7.604 14.887 16.018 14.887h48.069c9.149.001 16.489-7.655 15.995-16.79zm144.249.288C439.596 229.677 251.465 40.445 16.503 32.01 7.473 31.686.0 38.981.0 48.016v48.068c0 8.625 6.835 15.645 15.453 15.999 191.179 7.839 344.627 161.316 352.465 352.465.353 8.618 7.373 15.453 15.999 15.453h48.068c9.034-.001 16.329-7.474 16.005-16.504z"/></svg></a></footer></div></body></html>