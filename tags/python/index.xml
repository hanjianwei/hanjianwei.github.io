<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>python on Stone Horse</title><link>https://hanjianwei.com/tags/python/</link><description>Recent content in python on Stone Horse</description><generator>Hugo -- gohugo.io</generator><language>en</language><managingEditor>blog@hanjianwei.com (Jianwei Han)</managingEditor><webMaster>blog@hanjianwei.com (Jianwei Han)</webMaster><lastBuildDate>Thu, 25 Jul 2013 20:34:00 +0800</lastBuildDate><atom:link href="https://hanjianwei.com/tags/python/index.xml" rel="self" type="application/rss+xml"/><item><title>Python的方法解析顺序(MRO)</title><link>https://hanjianwei.com/2013/07/25/python-mro/</link><pubDate>Thu, 25 Jul 2013 20:34:00 +0800</pubDate><author>blog@hanjianwei.com (Jianwei Han)</author><guid>https://hanjianwei.com/2013/07/25/python-mro/</guid><description>对于支持继承的编程语言来说，其方法（属性）可能定义在当前类，也可能来自于基类，所以在方法调用时就需要对当前类和基类进行搜索以确定方法所在的位置。而搜索的顺序就是所谓的「方法解析顺序」（Method Resolution Order，或MRO）。对于只支持单继承的语言来说，MRO 一般比较简单；而对于 Python 这种支持多继承的语言来说，MRO 就复杂很多</description></item></channel></rss>